/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.12u-20020612-1249
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGPYTHON
/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) extern a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#                       define SWIGIMPORT(a) extern a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#                       define SWIGIMPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) a
#               endif
#       endif
#else
#       define SWIGEXPORT(a) a
#       define SWIGIMPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;                 
  swig_converter_func     converter;
  const char             *str;
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
  void                   *clientdata;	
} swig_type_info;

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);

#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  while (s) {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      return s;
    }
    s = s->next;
  }
  return 0;
}

/* Cast a pointer up an inheritance hierarchy */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Dynamic pointer casting. Down an inheritance hierarchy */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) 
{
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
     ty = (*ty->dcast)(ptr);
     if (ty) lastty = ty;
  }
  return lastty;
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* Set the clientdata field for a type */
SWIGRUNTIME(void)
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata) return;
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = swig_type_list;
      while (tc) {
	if ((strcmp(tc->name, equiv->name) == 0))
	  SWIG_TypeClientData(tc,clientdata);
	tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}
#endif

#ifdef __cplusplus
}

#endif

/***********************************************************************
 * python.swg
 *
 *     This file contains the runtime support for Python modules
 *     and includes code for managing global variables and pointer
 *     type checking.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 ************************************************************************/

#include <stdlib.h>
#include "Python.h"

#ifdef __cplusplus
extern "C" {
#endif

#define SWIG_PY_INT     1
#define SWIG_PY_FLOAT   2
#define SWIG_PY_STRING  3
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_const_info;

#ifdef SWIG_NOINCLUDE

SWIGEXPORT(PyObject *)        SWIG_newvarlink();
SWIGEXPORT(void)              SWIG_addvarlink(PyObject *, char *, PyObject *(*)(void), int (*)(PyObject *));
SWIGEXPORT(int)               SWIG_ConvertPtr(PyObject *, void **, swig_type_info *, int);
SWIGEXPORT(int)               SWIG_ConvertPacked(PyObject *, void *, int sz, swig_type_info *, int);
SWIGEXPORT(char *)            SWIG_PackData(char *c, void *, int);
SWIGEXPORT(char *)            SWIG_UnpackData(char *c, void *, int);
SWIGEXPORT(PyObject *)        SWIG_NewPointerObj(void *, swig_type_info *,int own);
SWIGEXPORT(PyObject *)        SWIG_NewPackedObj(void *, int sz, swig_type_info *);
SWIGEXPORT(void)              SWIG_InstallConstants(PyObject *d, swig_const_info constants[]);
#else

/* -----------------------------------------------------------------------------
 * global variable support code.
 * ----------------------------------------------------------------------------- */

typedef struct swig_globalvar {   
  char       *name;                  /* Name of global variable */
  PyObject *(*get_attr)(void);       /* Return the current value */
  int       (*set_attr)(PyObject *); /* Set the value */
  struct swig_globalvar *next;
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar *vars;
} swig_varlinkobject;

static PyObject *
swig_varlink_repr(swig_varlinkobject *v) {
  v = v;
  return PyString_FromString("<Global variables>");
}

static int
swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
  swig_globalvar  *var;
  flags = flags;
  fprintf(fp,"Global variables { ");
  for (var = v->vars; var; var=var->next) {
    fprintf(fp,"%s", var->name);
    if (var->next) fprintf(fp,", ");
  }
  fprintf(fp," }\n");
  return 0;
}

static PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->get_attr)();
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return NULL;
}

static int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->set_attr)(p);
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return 1;
}

statichere PyTypeObject varlinktype = {
  PyObject_HEAD_INIT(0)              
  0,
  (char *)"swigvarlink",                      /* Type name    */
  sizeof(swig_varlinkobject),         /* Basic size   */
  0,                                  /* Itemsize     */
  0,                                  /* Deallocator  */ 
  (printfunc) swig_varlink_print,     /* Print        */
  (getattrfunc) swig_varlink_getattr, /* get attr     */
  (setattrfunc) swig_varlink_setattr, /* Set attr     */
  0,                                  /* tp_compare   */
  (reprfunc) swig_varlink_repr,       /* tp_repr      */    
  0,                                  /* tp_as_number */
  0,                                  /* tp_as_mapping*/
  0,                                  /* tp_hash      */
};

/* Create a variable linking object for use later */
SWIGRUNTIME(PyObject *)
SWIG_newvarlink(void) {
  swig_varlinkobject *result = 0;
  result = PyMem_NEW(swig_varlinkobject,1);
  varlinktype.ob_type = &PyType_Type;    /* Patch varlinktype into a PyType */
  result->ob_type = &varlinktype;
  result->vars = 0;
  result->ob_refcnt = 0;
  Py_XINCREF((PyObject *) result);
  return ((PyObject*) result);
}

SWIGRUNTIME(void)
SWIG_addvarlink(PyObject *p, char *name,
	   PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
  swig_varlinkobject *v;
  swig_globalvar *gv;
  v= (swig_varlinkobject *) p;
  gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  gv->name = (char *) malloc(strlen(name)+1);
  strcpy(gv->name,name);
  gv->get_attr = get_attr;
  gv->set_attr = set_attr;
  gv->next = v->vars;
  v->vars = gv;
}

/* Pack binary data into a string */
SWIGRUNTIME(char *)
SWIG_PackData(char *c, void *ptr, int sz) {
  static char hex[17] = "0123456789abcdef";
  int i;
  unsigned char *u = (unsigned char *) ptr;
  register unsigned char uu;
  for (i = 0; i < sz; i++,u++) {
    uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* Unpack binary data from a string */
SWIGRUNTIME(char *)
SWIG_UnpackData(char *c, void *ptr, int sz) {
  register unsigned char uu;
  register int d;
  unsigned char *u = (unsigned char *) ptr;
  int i;
  for (i = 0; i < sz; i++, u++) {
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    *u = uu;
  }
  return c;
}

/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c;
  static PyObject *SWIG_this = 0;
  int    newref = 0;

  if (!obj) return 0;
  if (obj == Py_None) {
    *ptr = 0;
    return 0;
  }
#ifdef SWIG_COBJECT_TYPES
  if (!(PyCObject_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_InternFromString("this");
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyCObject_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  } 
  *ptr = PyCObject_AsVoidPtr(obj);
  c = (char *) PyCObject_GetDesc(obj);
  if (newref) Py_DECREF(obj);
  goto cobject;
#else
  if (!(PyString_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_InternFromString("this");
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyString_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  } 
  c = PyString_AsString(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0) {
      if (newref) Py_DECREF(obj);
      return 0;
    } else {
      if (newref) Py_DECREF(obj);
      goto type_error;
    }
  }
  c++;
  c = SWIG_UnpackData(c,ptr,sizeof(void *));
  if (newref) Py_DECREF(obj);
#endif

#ifdef SWIG_COBJECT_TYPES
cobject:
#endif

  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
    *ptr = SWIG_TypeCast(tc,(void*) *ptr);
  }
  return 0;

type_error:
  if (flags) {
    if (ty) {
      char *temp = (char *) malloc(64+strlen(ty->name));
      sprintf(temp,"Type error. Expected %s", ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Convert a packed value value */
SWIGRUNTIME(int)
SWIG_ConvertPacked(PyObject *obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c;

  if ((!obj) || (!PyString_Check(obj))) goto type_error;
  c = PyString_AsString(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c,ptr,sz);
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
  }
  return 0;

type_error:

  if (flags) {
    if (ty) {
      char *temp = (char *) malloc(64+strlen(ty->name));
      sprintf(temp,"Type error. Expected %s", ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Create a new pointer object */
SWIGRUNTIME(PyObject *)
SWIG_NewPointerObj(void *ptr, swig_type_info *type, int own) {
  PyObject *robj;
  if (!ptr) {
    Py_INCREF(Py_None);
    return Py_None;
  }
#ifdef SWIG_COBJECT_TYPES
  robj = PyCObject_FromVoidPtrAndDesc((void *) ptr, (char *) type->name, NULL);
#else
  {
    char result[512];
    char *r = result;
    *(r++) = '_';
    r = SWIG_PackData(r,&ptr,sizeof(void *));
    strcpy(r,type->name);
    robj = PyString_FromString(result);
  }
#endif
  if (!robj || (robj == Py_None)) return robj;
  if (type->clientdata) {
    PyObject *inst;
    PyObject *args = Py_BuildValue((char*)"(O)", robj);
    Py_DECREF(robj);
    inst = PyObject_CallObject((PyObject *) type->clientdata, args);
    Py_DECREF(args);
    if (own) {
      PyObject *n = PyInt_FromLong(1);
      PyObject_SetAttrString(inst,(char*)"thisown",n);
      Py_DECREF(n);
    }
    robj = inst;
  }
  return robj;
}

SWIGRUNTIME(PyObject *)
SWIG_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,type->name);
  return PyString_FromString(result);
}

/* Install Constants */
SWIGRUNTIME(void)
SWIG_InstallConstants(PyObject *d, swig_const_info constants[]) {
  int i;
  PyObject *obj;
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_PY_INT:
      obj = PyInt_FromLong(constants[i].lvalue);
      break;
    case SWIG_PY_FLOAT:
      obj = PyFloat_FromDouble(constants[i].dvalue);
      break;
    case SWIG_PY_STRING:
      obj = PyString_FromString((char *) constants[i].pvalue);
      break;
    case SWIG_PY_POINTER:
      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
      break;
    case SWIG_PY_BINARY:
      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
      break;
    default:
      obj = 0;
      break;
    }
    if (obj) {
      PyDict_SetItemString(d,constants[i].name,obj);
      Py_DECREF(obj);
    }
  }
}

#endif

#ifdef __cplusplus
}
#endif








/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_pcapObject swig_types[0] 
#define  SWIGTYPE_p_pcap_pkthdr swig_types[1] 
#define  SWIGTYPE_p_pcap_dumper_t swig_types[2] 
#define  SWIGTYPE_p_pcap_t swig_types[3] 
#define  SWIGTYPE_p_u_char swig_types[4] 
static swig_type_info *swig_types[6];

/* -------- TYPES TABLE (END) -------- */


/*-----------------------------------------------
              @(target):= pcapc.so
  ------------------------------------------------*/
#define SWIG_init    initpcapc

#define SWIG_name    "pcapc"

#include <pcap.h>
#include "pypcap.h"

 static char _doc_pcapObject_pcap_set[] = "set pcapObject pcap attribute"; 
 static char _doc_pcapObject_pcap_get[] = "get pcapObject pcap attribute"; 
 static char _doc_pcapObject_pcap_dumper_set[] = "set pcapObject pcap_dumper attribute"; 
 static char _doc_pcapObject_pcap_dumper_get[] = "get pcapObject pcap_dumper attribute"; 
 static char _doc_pcapObject_callback_set[] = "set pcapObject callback attribute"; 
 static char _doc_pcapObject_callback_get[] = "get pcapObject callback attribute"; 
 static char _doc_new_pcapObject[] = "create a pcapObject instance"; 
 static char _doc_delete_pcapObject[] = "destroy a pcapObject instance"; 
 static char _doc_pcapObject_open_live[] =  "open_live(device, snaplen, promisc, to_ms)\n\n"  "Opens the interface specificed by 'device' for packet capture. 'snaplen'\n" "is the maximum number of bytes to capture per packet, 'promisc' indicates\n" "whether promiscuous mode should be used, and 'to_ms' specifies the read\n" "timeout in milliseconds."; 
 static char _doc_pcapObject_open_dead[] =  "open_dead(linktype, snaplen)\n\n"  "open_dead is used to initialize the pcapObject so that methods that\n" "require the object to be initialized can be called, such as for compiling\n" "BPF code.  'snaplen' is the maximum number of bytes to capture per packet."; 
 static char _doc_pcapObject_open_offline[] =  "open_offline(filename)\n\n"  "Opens a saved pcap/tcpdump-format file for reading. 'filename' is the name\n" "of the file to open.  The filename '-' is synonymous with stdin"; 
 static char _doc_pcapObject_dump_open[] =  "dump_open(filename)\n\n"  "Opens a saved pcap/tcpdump-format file for writing. 'filename' is the name\n" "of the file to open.  The filename '-' is synonymous with stdout"; 
 static char _doc_pcapObject_setnonblock[] =  "setnonblock(nonblock)\n\n"  "Puts the pcapObject in non-blocking mode ('nonblock'==1) or blocking mode\n" "('nonblock'==0).  Non-blocking behavior is only applicable to the\n" "dispatch method, and not the loop and next methods.  It has no effect on\n" "savefiles."; 
 static char _doc_pcapObject_getnonblock[] =  "getnonblock()\n\n"  "Returns the non-blocking status of the pcapObject (returns 1 for\n" "non-blocking, returns 0 for blocking).  0 is always returned for savefiles\n" "Non-blocking behavior is only applicable to the dispatch method, and not\n" "the loop and next methods.  It has no effect on savefiles."; 
 static char _doc_pcapObject_setfilter[] =  "setfilter(filter, optimize, netmask)\n\n"  "Applies a filtering rule to the pcapObject.  'filter' is a BPF-style \n" "filter expression, 'optimize' controls whether the compiled BPF code is \n" "optimized, and 'netmask' in a network byte-order integer specifying the \n" "netmask of the local network."; 
 static char _doc_pcapObject_loop[] =  "loop(count, callback)\n\n"  "Read packets until 'count' packets have been received or an exception\n" "occurs.  The 'callback' argument is a python function of the form\n" "callback(pktlen, data, timestamp).  'pktlen' is the integer length of the\n" "observed packet on the wire, data is a string containing the captured\n" "bytes (may be less than the pktlen bytes), and the timestamp."; 
 static char _doc_pcapObject_dispatch[] =  "dispatch(count, callback)\n\n"  "Read packets until at most 'count' packets have been read, or a timeout" "occurs, or an exception is raised.  Timeout behavior is not supported on\n" "all platforms, and on some platforms, the timer doesn't start until at least\n" "one packet arrives.  \n" "The 'callback' argument is a python function of the form\n" "callback(pktlen, data, timestamp).  'pktlen' is the integer length of the\n" "observed packet on the wire, data is a string containing the captured\n" "bytes (may be less than the pktlen bytes), and the timestamp."; 
 static char _doc_pcapObject_next[] =  "next()\n\n"  "Reads the next packet from the interface, returning a tuple containing\n" "the integer length of the observed packet on the wire, a string containing\n" "the captured bytes (may be less than the pktlen bytes), and the timestamp."; 
 static char _doc_pcapObject_datalink[] =  "datalink()\n\n"  "Returns an integer value representing the link layer type (i.e. DLT_EN10MB)"; 
 static char _doc_pcapObject_snapshot[] =  "snapshot()\n\n"  "Returns tho snapshot length specificed with open_live was called"; 
 static char _doc_pcapObject_is_swapped[] =  "is_swapped()\n\n"  "Returns true if the current savefile uses a different byte order than the\n" "current system"; 
 static char _doc_pcapObject_major_version[] =  "major_version()\n\n"  "returns the major number of the version of the pcap used to write the savefile.\n"; 
 static char _doc_pcapObject_minor_version[] =  "minor_version()\n\n"  "returns the minor number of the version of the pcap used to write the savefile.\n"; 
 static char _doc_pcapObject_stats[] =  "stats()\n\n"  "Returns a tuple containing number of packets received, number of packets\n" "dropped, and number of packets dropped by the interface.  This method is\n" "not applicable for savefiles"; 
 static char _doc_pcapObject_fileno[] =  "fileno()\n\n" "Returns the file descriptor number from which captured packets are read,\n" "if a network device was opened with open_live(), or -1, if a savefile was\n" "opened with pcap_open_offline()."; 
 static char _doc_lookupdev[] =  "lookupdev()\n\n"  "Returns a string containing the name of an interface suitable for use\n"  "with pcapObject.open_live and lookupnet.\n"; 
 static char _doc_findalldevs[] =  "findalldevs()\n\n"  "Returns a list of tuples for each device that can be opened with\n"  "open_live(). Each tuple contains the following members:\n"  "  name\n"  "  description\n"  "  addressess: a tuple of tuples for each address, containing the address,\n"  "    netmask, broadcast address, and point-to-point address.\n"  "  flags: PCAP_IF_LOOPBACK if a loopback interface\n"; 
 static char _doc_lookupnet[] =  "lookupnet(interface)\n\n"  "Returns a tuple containing the network number and mask associated with\n"  "the network device 'interface' in network byte order.\n"; 
 static char _doc_PythonCallBack[] = "internal function - do not use"; 
 static char _doc_aton[] = "aton(addr)\n\nconvert dotted decimal IP string to network byte order int"; 
 static char _doc_ntoa[] = "ntoa(addr)\n\nconvert network byte order int to dotted decimal IP string"; 
#ifdef __cplusplus
extern "C" {
#endif
static PyObject *_wrap_pcapObject_pcap_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    pcap_t *arg2 ;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:pcapObject_pcap_set",&obj0,&obj1)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_pcap_t,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        if (arg1) arg1->pcap = arg2;
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_pcapObject_pcap_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    pcap_t *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:pcapObject_pcap_get",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        result = (pcap_t *) (arg1->pcap);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_pcap_t, 0);
    return resultobj;
}


static PyObject *_wrap_pcapObject_pcap_dumper_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    pcap_dumper_t *arg2 ;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:pcapObject_pcap_dumper_set",&obj0,&obj1)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_pcap_dumper_t,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        if (arg1) arg1->pcap_dumper = arg2;
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_pcapObject_pcap_dumper_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    pcap_dumper_t *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:pcapObject_pcap_dumper_get",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        result = (pcap_dumper_t *) (arg1->pcap_dumper);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_pcap_dumper_t, 0);
    return resultobj;
}


static PyObject *_wrap_pcapObject_callback_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    PyObject *arg2 ;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:pcapObject_callback_set",&obj0,&obj1)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        arg2 = obj1;
    }
    {
        int err;
        clear_exception();
        if (arg1) arg1->callback = arg2;
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_pcapObject_callback_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    PyObject *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:pcapObject_callback_get",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        result = (PyObject *) (arg1->callback);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    {
        resultobj = result;
    }
    return resultobj;
}


static PyObject *_wrap_new_pcapObject(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_pcapObject")) return NULL;
    {
        int err;
        clear_exception();
        result = (pcapObject *)new_pcapObject();
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_pcapObject, 1);
    return resultobj;
}


static PyObject *_wrap_delete_pcapObject(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_pcapObject",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        delete_pcapObject(arg1);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_pcapObject_open_live(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    char *arg2 ;
    int arg3 ;
    int arg4 ;
    int arg5 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Osiii:pcapObject_open_live",&obj0,&arg2,&arg3,&arg4,&arg5)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        pcapObject_open_live(arg1,arg2,arg3,arg4,arg5);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_pcapObject_open_dead(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    int arg2 ;
    int arg3 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:pcapObject_open_dead",&obj0,&arg2,&arg3)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        pcapObject_open_dead(arg1,arg2,arg3);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_pcapObject_open_offline(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    char *arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:pcapObject_open_offline",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        pcapObject_open_offline(arg1,arg2);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_pcapObject_dump_open(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    char *arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:pcapObject_dump_open",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        pcapObject_dump_open(arg1,arg2);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_pcapObject_setnonblock(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    int arg2 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:pcapObject_setnonblock",&obj0,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        pcapObject_setnonblock(arg1,arg2);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_pcapObject_getnonblock(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    int result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:pcapObject_getnonblock",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        result = (int)pcapObject_getnonblock(arg1);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pcapObject_setfilter(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    char *arg2 ;
    int arg3 ;
    int arg4 ;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Osii:pcapObject_setfilter",&obj0,&arg2,&arg3,&arg4)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        pcapObject_setfilter(arg1,arg2,arg3,arg4);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_pcapObject_loop(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    int arg2 ;
    PyObject *arg3 ;
    PyObject * obj0  = 0 ;
    PyObject * obj2  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:pcapObject_loop",&obj0,&arg2,&obj2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        arg3 = obj2;
    }
    {
        int err;
        clear_exception();
        pcapObject_loop(arg1,arg2,arg3);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_pcapObject_dispatch(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    int arg2 ;
    PyObject *arg3 ;
    PyObject * obj0  = 0 ;
    PyObject * obj2  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OiO:pcapObject_dispatch",&obj0,&arg2,&obj2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        arg3 = obj2;
    }
    {
        int err;
        clear_exception();
        pcapObject_dispatch(arg1,arg2,arg3);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_pcapObject_next(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    PyObject *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:pcapObject_next",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        result = (PyObject *)pcapObject_next(arg1);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    {
        resultobj = result;
    }
    return resultobj;
}


static PyObject *_wrap_pcapObject_datalink(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    int result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:pcapObject_datalink",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        result = (int)pcapObject_datalink(arg1);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pcapObject_snapshot(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    int result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:pcapObject_snapshot",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        result = (int)pcapObject_snapshot(arg1);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pcapObject_is_swapped(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    int result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:pcapObject_is_swapped",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        result = (int)pcapObject_is_swapped(arg1);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pcapObject_major_version(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    int result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:pcapObject_major_version",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        result = (int)pcapObject_major_version(arg1);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pcapObject_minor_version(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    int result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:pcapObject_minor_version",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        result = (int)pcapObject_minor_version(arg1);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject *_wrap_pcapObject_stats(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    PyObject *result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:pcapObject_stats",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        result = (PyObject *)pcapObject_stats(arg1);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    {
        resultobj = result;
    }
    return resultobj;
}


static PyObject *_wrap_pcapObject_fileno(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    pcapObject *arg1 ;
    int result;
    PyObject * obj0  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:pcapObject_fileno",&obj0)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pcapObject,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        result = (int)pcapObject_fileno(arg1);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


static PyObject * pcapObject_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_pcapObject, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_lookupdev(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *result;
    
    if(!PyArg_ParseTuple(args,(char *)":lookupdev")) return NULL;
    {
        int err;
        clear_exception();
        result = (char *)lookupdev();
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
}


static PyObject *_wrap_findalldevs(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    PyObject *result;
    
    if(!PyArg_ParseTuple(args,(char *)":findalldevs")) return NULL;
    {
        int err;
        clear_exception();
        result = (PyObject *)findalldevs();
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    {
        resultobj = result;
    }
    return resultobj;
}


static PyObject *_wrap_lookupnet(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    PyObject *result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:lookupnet",&arg1)) return NULL;
    {
        int err;
        clear_exception();
        result = (PyObject *)lookupnet(arg1);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    {
        resultobj = result;
    }
    return resultobj;
}


static PyObject *_wrap_PythonCallBack(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    u_char *arg1 ;
    struct pcap_pkthdr *arg2 ;
    u_char *arg3 ;
    PyObject * obj0  = 0 ;
    PyObject * obj1  = 0 ;
    PyObject * obj2  = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:PythonCallBack",&obj0,&obj1,&obj2)) return NULL;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_u_char,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_pcap_pkthdr,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_u_char,1)) == -1) return NULL;
    {
        int err;
        clear_exception();
        PythonCallBack(arg1,(struct pcap_pkthdr const *)arg2,(u_char const *)arg3);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
}


static PyObject *_wrap_aton(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    PyObject *result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:aton",&arg1)) return NULL;
    {
        int err;
        clear_exception();
        result = (PyObject *)aton(arg1);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    {
        resultobj = result;
    }
    return resultobj;
}


static PyObject *_wrap_ntoa(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:ntoa",&arg1)) return NULL;
    {
        int err;
        clear_exception();
        result = (char *)ntoa(arg1);
        
        if ((err = check_exception())) {
            set_error(err, get_exception_message());
            return NULL;
        }
        else if(PyErr_Occurred()) {
            return NULL;
        }
    }
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
}


static PyMethodDef SwigMethods[] = {
	{ (char *)"pcapObject_pcap_set", _wrap_pcapObject_pcap_set, METH_VARARGS, _doc_pcapObject_pcap_set },
	{ (char *)"pcapObject_pcap_get", _wrap_pcapObject_pcap_get, METH_VARARGS, _doc_pcapObject_pcap_get },
	{ (char *)"pcapObject_pcap_dumper_set", _wrap_pcapObject_pcap_dumper_set, METH_VARARGS, _doc_pcapObject_pcap_dumper_set },
	{ (char *)"pcapObject_pcap_dumper_get", _wrap_pcapObject_pcap_dumper_get, METH_VARARGS, _doc_pcapObject_pcap_dumper_get },
	{ (char *)"pcapObject_callback_set", _wrap_pcapObject_callback_set, METH_VARARGS, _doc_pcapObject_callback_set },
	{ (char *)"pcapObject_callback_get", _wrap_pcapObject_callback_get, METH_VARARGS, _doc_pcapObject_callback_get },
	{ (char *)"new_pcapObject", _wrap_new_pcapObject, METH_VARARGS, _doc_new_pcapObject },
	{ (char *)"delete_pcapObject", _wrap_delete_pcapObject, METH_VARARGS, _doc_delete_pcapObject },
	{ (char *)"pcapObject_open_live", _wrap_pcapObject_open_live, METH_VARARGS, _doc_pcapObject_open_live },
	{ (char *)"pcapObject_open_dead", _wrap_pcapObject_open_dead, METH_VARARGS, _doc_pcapObject_open_dead },
	{ (char *)"pcapObject_open_offline", _wrap_pcapObject_open_offline, METH_VARARGS, _doc_pcapObject_open_offline },
	{ (char *)"pcapObject_dump_open", _wrap_pcapObject_dump_open, METH_VARARGS, _doc_pcapObject_dump_open },
	{ (char *)"pcapObject_setnonblock", _wrap_pcapObject_setnonblock, METH_VARARGS, _doc_pcapObject_setnonblock },
	{ (char *)"pcapObject_getnonblock", _wrap_pcapObject_getnonblock, METH_VARARGS, _doc_pcapObject_getnonblock },
	{ (char *)"pcapObject_setfilter", _wrap_pcapObject_setfilter, METH_VARARGS, _doc_pcapObject_setfilter },
	{ (char *)"pcapObject_loop", _wrap_pcapObject_loop, METH_VARARGS, _doc_pcapObject_loop },
	{ (char *)"pcapObject_dispatch", _wrap_pcapObject_dispatch, METH_VARARGS, _doc_pcapObject_dispatch },
	{ (char *)"pcapObject_next", _wrap_pcapObject_next, METH_VARARGS, _doc_pcapObject_next },
	{ (char *)"pcapObject_datalink", _wrap_pcapObject_datalink, METH_VARARGS, _doc_pcapObject_datalink },
	{ (char *)"pcapObject_snapshot", _wrap_pcapObject_snapshot, METH_VARARGS, _doc_pcapObject_snapshot },
	{ (char *)"pcapObject_is_swapped", _wrap_pcapObject_is_swapped, METH_VARARGS, _doc_pcapObject_is_swapped },
	{ (char *)"pcapObject_major_version", _wrap_pcapObject_major_version, METH_VARARGS, _doc_pcapObject_major_version },
	{ (char *)"pcapObject_minor_version", _wrap_pcapObject_minor_version, METH_VARARGS, _doc_pcapObject_minor_version },
	{ (char *)"pcapObject_stats", _wrap_pcapObject_stats, METH_VARARGS, _doc_pcapObject_stats },
	{ (char *)"pcapObject_fileno", _wrap_pcapObject_fileno, METH_VARARGS, _doc_pcapObject_fileno },
	 { (char *)"pcapObject_swigregister", pcapObject_swigregister, METH_VARARGS },
	{ (char *)"lookupdev", _wrap_lookupdev, METH_VARARGS, _doc_lookupdev },
	{ (char *)"findalldevs", _wrap_findalldevs, METH_VARARGS, _doc_findalldevs },
	{ (char *)"lookupnet", _wrap_lookupnet, METH_VARARGS, _doc_lookupnet },
	{ (char *)"PythonCallBack", _wrap_PythonCallBack, METH_VARARGS, _doc_PythonCallBack },
	{ (char *)"aton", _wrap_aton, METH_VARARGS, _doc_aton },
	{ (char *)"ntoa", _wrap_ntoa, METH_VARARGS, _doc_ntoa },
	 { NULL, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_pcapObject[] = {{"_p_pcapObject", 0, "pcapObject *"},{"_p_pcapObject"},{0}};
static swig_type_info _swigt__p_pcap_pkthdr[] = {{"_p_pcap_pkthdr", 0, "struct pcap_pkthdr *"},{"_p_pcap_pkthdr"},{0}};
static swig_type_info _swigt__p_pcap_dumper_t[] = {{"_p_pcap_dumper_t", 0, "pcap_dumper_t *"},{"_p_pcap_dumper_t"},{0}};
static swig_type_info _swigt__p_pcap_t[] = {{"_p_pcap_t", 0, "pcap_t *"},{"_p_pcap_t"},{0}};
static swig_type_info _swigt__p_u_char[] = {{"_p_u_char", 0, "u_char *"},{"_p_u_char"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_pcapObject, 
_swigt__p_pcap_pkthdr, 
_swigt__p_pcap_dumper_t, 
_swigt__p_pcap_t, 
_swigt__p_u_char, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{ SWIG_PY_STRING,  (char*)"pcap_doc", 0, 0, (void *)"pcap module\n-----------\npcapObject(): Returns a pcapObject instance, with the following methods.\nPlease see the __doc__ attributes of the instance methods of a pcapObject\nfor more information. (there are no method __doc__ attributes in the\nclass). Also please note that at this time, method __doc__ attributes are\nonly functional for python2.\n  open_live(device, snaplen, promisc, to_ms)\n  open_dead(linktype, snaplen)\n  open_offline(filename)\n  dump_open(filename)\n  setnonblock(nonblock)\n  getnonblock()\n  setfilter(filter, optimize, netmask)\n  loop(count, callback)\n  dispatch(count, callback)\n  next()\n  datalink()\n  snapshot()\n  is_swapped()\n  major_version()\n  stats()\n  fileno()\n\nPlease see the __doc__ attributes of the following pcap module functions\nfor further information:\n  lookupdev()\n  lookupnet(device)\n  findalldevs()\n  aton(addr)\n  ntoa(addr)\n", 0},
{ SWIG_PY_STRING,  (char*)"pcapObject_open_live_doc", 0, 0, (void *)"open_live(device, snaplen, promisc, to_ms)\n\nOpens the interface specificed by \'device\' for packet capture. \'snaplen\'\nis the maximum number of bytes to capture per packet, \'promisc\' indicates\nwhether promiscuous mode should be used, and \'to_ms\' specifies the read\ntimeout in milliseconds.", 0},
{ SWIG_PY_STRING,  (char*)"pcapObject_open_dead_doc", 0, 0, (void *)"open_dead(linktype, snaplen)\n\nopen_dead is used to initialize the pcapObject so that methods that\nrequire the object to be initialized can be called, such as for compiling\nBPF code.  \'snaplen\' is the maximum number of bytes to capture per packet.", 0},
{ SWIG_PY_STRING,  (char*)"pcapObject_open_offline_doc", 0, 0, (void *)"open_offline(filename)\n\nOpens a saved pcap/tcpdump-format file for reading. \'filename\' is the name\nof the file to open.  The filename \'-\' is synonymous with stdin", 0},
{ SWIG_PY_STRING,  (char*)"pcapObject_dump_open_doc", 0, 0, (void *)"dump_open(filename)\n\nOpens a saved pcap/tcpdump-format file for writing. \'filename\' is the name\nof the file to open.  The filename \'-\' is synonymous with stdout", 0},
{ SWIG_PY_STRING,  (char*)"pcapObject_setnonblock_doc", 0, 0, (void *)"setnonblock(nonblock)\n\nPuts the pcapObject in non-blocking mode (\'nonblock\'==1) or blocking mode\n(\'nonblock\'==0).  Non-blocking behavior is only applicable to the\ndispatch method, and not the loop and next methods.  It has no effect on\nsavefiles.", 0},
{ SWIG_PY_STRING,  (char*)"pcapObject_getnonblock_doc", 0, 0, (void *)"getnonblock()\n\nReturns the non-blocking status of the pcapObject (returns 1 for\nnon-blocking, returns 0 for blocking).  0 is always returned for savefiles\nNon-blocking behavior is only applicable to the dispatch method, and not\nthe loop and next methods.  It has no effect on savefiles.", 0},
{ SWIG_PY_STRING,  (char*)"pcapObject_setfilter_doc", 0, 0, (void *)"setfilter(filter, optimize, netmask)\n\nApplies a filtering rule to the pcapObject.  \'filter\' is a BPF-style \nfilter expression, \'optimize\' controls whether the compiled BPF code is \noptimized, and \'netmask\' in a network byte-order integer specifying the \nnetmask of the local network.", 0},
{ SWIG_PY_STRING,  (char*)"pcapObject_loop_doc", 0, 0, (void *)"loop(count, callback)\n\nRead packets until \'count\' packets have been received or an exception\noccurs.  The \'callback\' argument is a python function of the form\ncallback(pktlen, data, timestamp).  \'pktlen\' is the integer length of the\nobserved packet on the wire, data is a string containing the captured\nbytes (may be less than the pktlen bytes), and the timestamp.", 0},
{ SWIG_PY_STRING,  (char*)"pcapObject_dispatch_doc", 0, 0, (void *)"dispatch(count, callback)\n\nRead packets until at most \'count\' packets have been read, or a timeoutoccurs, or an exception is raised.  Timeout behavior is not supported on\nall platforms, and on some platforms, the timer doesn\'t start until at least\none packet arrives.  \nThe \'callback\' argument is a python function of the form\ncallback(pktlen, data, timestamp).  \'pktlen\' is the integer length of the\nobserved packet on the wire, data is a string containing the captured\nbytes (may be less than the pktlen bytes), and the timestamp.", 0},
{ SWIG_PY_STRING,  (char*)"pcapObject_next_doc", 0, 0, (void *)"next()\n\nReads the next packet from the interface, returning a tuple containing\nthe integer length of the observed packet on the wire, a string containing\nthe captured bytes (may be less than the pktlen bytes), and the timestamp.", 0},
{ SWIG_PY_STRING,  (char*)"pcapObject_datalink_doc", 0, 0, (void *)"datalink()\n\nReturns an integer value representing the link layer type (i.e. DLT_EN10MB)", 0},
{ SWIG_PY_STRING,  (char*)"pcapObject_snapshot_doc", 0, 0, (void *)"snapshot()\n\nReturns tho snapshot length specificed with open_live was called", 0},
{ SWIG_PY_STRING,  (char*)"pcapObject_is_swapped_doc", 0, 0, (void *)"is_swapped()\n\nReturns true if the current savefile uses a different byte order than the\ncurrent system", 0},
{ SWIG_PY_STRING,  (char*)"pcapObject_major_version_doc", 0, 0, (void *)"major_version()\n\nreturns the major number of the version of the pcap used to write the savefile.\n", 0},
{ SWIG_PY_STRING,  (char*)"pcapObject_minor_version_doc", 0, 0, (void *)"minor_version()\n\nreturns the minor number of the version of the pcap used to write the savefile.\n", 0},
{ SWIG_PY_STRING,  (char*)"pcapObject_stats_doc", 0, 0, (void *)"stats()\n\nReturns a tuple containing number of packets received, number of packets\ndropped, and number of packets dropped by the interface.  This method is\nnot applicable for savefiles", 0},
{ SWIG_PY_STRING,  (char*)"pcapObject_fileno_doc", 0, 0, (void *)"fileno()\n\nReturns the file descriptor number from which captured packets are read,\nif a network device was opened with open_live(), or -1, if a savefile was\nopened with pcap_open_offline().", 0},
{ SWIG_PY_STRING,  (char*)"lookupdev_doc", 0, 0, (void *)"lookupdev()\n\nReturns a string containing the name of an interface suitable for use\nwith pcapObject.open_live and lookupnet.\n", 0},
{ SWIG_PY_STRING,  (char*)"lookupnet_doc", 0, 0, (void *)"lookupnet(interface)\n\nReturns a tuple containing the network number and mask associated with\nthe network device \'interface\' in network byte order.\n", 0},
{ SWIG_PY_STRING,  (char*)"findalldevs_doc", 0, 0, (void *)"findalldevs()\n\nReturns a list of tuples for each device that can be opened with\nopen_live(). Each tuple contains the following members:\n  name\n  description\n  addressess: a tuple of tuples for each address, containing the address,\n    netmask, broadcast address, and point-to-point address.\n  flags: PCAP_IF_LOOPBACK if a loopback interface\n", 0},
{ SWIG_PY_STRING,  (char*)"__doc__", 0, 0, (void *)"pcap module\n-----------\npcapObject(): Returns a pcapObject instance, with the following methods.\nPlease see the __doc__ attributes of the instance methods of a pcapObject\nfor more information. (there are no method __doc__ attributes in the\nclass). Also please note that at this time, method __doc__ attributes are\nonly functional for python2.\n  open_live(device, snaplen, promisc, to_ms)\n  open_dead(linktype, snaplen)\n  open_offline(filename)\n  dump_open(filename)\n  setnonblock(nonblock)\n  getnonblock()\n  setfilter(filter, optimize, netmask)\n  loop(count, callback)\n  dispatch(count, callback)\n  next()\n  datalink()\n  snapshot()\n  is_swapped()\n  major_version()\n  stats()\n  fileno()\n\nPlease see the __doc__ attributes of the following pcap module functions\nfor further information:\n  lookupdev()\n  lookupnet(device)\n  findalldevs()\n  aton(addr)\n  ntoa(addr)\n", 0},
{ SWIG_PY_INT,     (char *)"DLT_NULL", (long) DLT_NULL, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_EN10MB", (long) DLT_EN10MB, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_EN3MB", (long) DLT_EN3MB, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_AX25", (long) DLT_AX25, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_PRONET", (long) DLT_PRONET, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_CHAOS", (long) DLT_CHAOS, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_IEEE802", (long) DLT_IEEE802, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_ARCNET", (long) DLT_ARCNET, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_SLIP", (long) DLT_SLIP, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_PPP", (long) DLT_PPP, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_FDDI", (long) DLT_FDDI, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_ATM_RFC1483", (long) DLT_ATM_RFC1483, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_RAW", (long) DLT_RAW, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_SLIP_BSDOS", (long) DLT_SLIP_BSDOS, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_PPP_BSDOS", (long) DLT_PPP_BSDOS, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_ATM_CLIP", (long) DLT_ATM_CLIP, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_PPP_SERIAL", (long) DLT_PPP_SERIAL, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_PPP_ETHER", (long) DLT_PPP_ETHER, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_C_HDLC", (long) DLT_C_HDLC, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_CHDLC", (long) DLT_CHDLC, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_IEEE802_11", (long) DLT_IEEE802_11, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_LOOP", (long) DLT_LOOP, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_LINUX_SLL", (long) DLT_LINUX_SLL, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_LTALK", (long) DLT_LTALK, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_ECONET", (long) DLT_ECONET, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_IPFILTER", (long) DLT_IPFILTER, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_PFLOG", (long) DLT_PFLOG, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_CISCO_IOS", (long) DLT_CISCO_IOS, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_PRISM_HEADER", (long) DLT_PRISM_HEADER, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"DLT_AIRONET_HEADER", (long) DLT_AIRONET_HEADER, 0, 0, 0},
{0}};

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT(void) SWIG_init(void) {
    static PyObject *SWIG_globals = 0; 
    static int       typeinit = 0;
    PyObject *m, *d;
    int       i;
    if (!SWIG_globals) SWIG_globals = SWIG_newvarlink();
    m = Py_InitModule((char *) SWIG_name, SwigMethods);
    d = PyModule_GetDict(m);
    
    if (!typeinit) {
        for (i = 0; swig_types_initial[i]; i++) {
            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
        }
        typeinit = 1;
    }
    SWIG_InstallConstants(d,swig_const_table);
    
    
    /* d is the dictionary for the current module */
    init_errors(d);
    
    
}

